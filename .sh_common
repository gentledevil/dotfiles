#!/bin/sh

### Options ###
set -o emacs

# umask, different if root
[ "$(id -u)" != 0 ] && umask 027 || umask 022

### Environment ###

export EDITOR=vim
export PAGER=less
export SYSTEMD_PAGER=cat
export GIT_PAGER=cat
export BROWSER=firefox
unset MAILCHECK

# less
export LESS=-wRim

# make less more friendly for non-text input files, see lesspipe(1)
which lesspipe >/dev/null 2>&1 && eval "$(SHELL=/bin/sh lesspipe)"
which lesspipe.sh >/dev/null 2>&1 && eval "$(SHELL=/bin/sh lesspipe.sh)"

### Aliases ###

alias l="ls"
alias ll="ls -lh"
alias l.="ls -ld .*"
alias la="ls -lhA"
alias lx="ls -lhAxb"          # sort by extension
alias lk="ls -lhASr"          # sort by size, biggest last
alias lt="ls -lhAtr"          # sort by date, most recent last
alias lsb="ls -ail"
alias sl="ls"
alias cta="cat"
alias rm="rm -i"
alias cp="cp -i"
alias mv="mv -i"
alias g='egrep -i'
alias open="xdg-open"
alias trash="gvfs-trash"
alias e="emacs -nw"
alias vi="vim"
alias parallel="parallel --will-cite"
alias sudo="sudo "            # allow to perform alias expansion

### Functions ###

cl() {
	cd "$1" && ls
}

md() {
	mkdir -p "$1" && cd "$1"
}

h() {
	test -z "$1" && history || history | egrep -i "$1"
}

### Color ###

if [ ! -z "$COLORTERM" ]
then
	# 256 colors in terminal
	TERM=xterm-256color
fi
export CLICOLOR=true
if which dircolors >/dev/null 2>&1; then
	eval "$(dircolors ~/.dircolors)"
fi
if ls --version 2>/dev/null | grep -q GNU; then
	alias ls="ls --color=auto --group-directories-first"
fi
if which colordiff >/dev/null 2>&1; then
	alias diff=colordiff
fi
if [ -f "/usr/lib/libstderred.so" ]; then
	export LD_PRELOAD="/usr/lib/libstderred.so"
fi
if [ "$(uname)" = "Linux" ]; then
	alias dmesg="dmesg -TL"
fi
if grep -V 2>/dev/null | grep -q GNU; then
	alias grep="grep --color=auto"
	alias egrep="egrep --color=auto"
	alias fgrep="fgrep --color=auto"
fi
alias tree="tree -C"

# use control chars directly because tput may be broken
RED="[31m"
BG_RED="[41m"
GREEN="[32m"
YELLOW="[33m"
BLUE="[34m"
MAGENTA="[35m"
CYAN="[36m"
WHITE="[37m"
BOLD="[01m"
RESET="[00m"

man() {
	env \
	LESS_TERMCAP_mb=${BOLD}${GREEN}             \
	LESS_TERMCAP_md=${BOLD}${GREEN}             \
	LESS_TERMCAP_so=${BOLD}${WHITE}${BG_RED}    \
	LESS_TERMCAP_us=${BOLD}${MAGENTA}           \
	LESS_TERMCAP_me=${RESET}                    \
	LESS_TERMCAP_se=${RESET}                    \
	LESS_TERMCAP_ue=${RESET}                    \
	man "$@"
}

# a colorful prompt that works on {a,da,ba,mk,pdk,z}sh
# and probably other Bourne/POSIX variants
get_git_branch() {
	git branch 2> /dev/null | sed -e '/^[^*]/d;s/* \(.*\)/(\1)/'
}

get_exit_status() {
	EXIT_STATUS="$?"
	if [ ${EXIT_STATUS} -ne 0 ]; then
		echo "${EXIT_STATUS}${RESET} "
	fi
}

if [ `id -u` = 0 ]; then
        USER_COLOR="${MAGENTA}${BOLD}"
        USER_CHAR='ðŸ‘‘'
else
        USER_COLOR="${YELLOW}"
        USER_CHAR=''
fi

if [ -z $HOST ]; then
        HOST=`hostname`
fi

if [ ! -z $ZSH_VERSION ]; then
        WORK_DIR='%~'
elif [ ! -z $OLDPWD ]; then
	WORK_DIR=\${PWD}
else
	WORK_DIR='\w'
fi

if [ ! -z "$BASH" -o ! -z "$ZSH_VERSION" ]; then
	EXIT_STATUS="\`get_exit_status\`"
	GIT_BRANCH="\`get_git_branch\`"
	# Source git prompt stuff
	if [ -f /usr/share/git/git-prompt.sh ]; then
		source /usr/share/git/git-prompt.sh
		export GIT_PS1_SHOWDIRTYSTATE=true
		export GIT_PS1_SHOWUNTRACKEDFILES=true
		export GIT_PS1_SHOWSTASHSTATE=true
		GIT_BRANCH="\`__git_ps1\`"
	fi
fi

if [ -f /run/reboot-required ]; then
	REBOOT='${RED}[!]'
fi

PS1="â”Œâ”€ ${BG_RED}${BOLD}${WHITE}${EXIT_STATUS}${RESET}${USER_COLOR}${USER}${RESET}${CYAN}@${HOST}:${CYAN}${WORK_DIR}${MAGENTA}${GIT_BRANCH} ${YELLOW}${REBOOT:-$USER_CHAR}${RESET}
â””â•¼ "

[ $TERM = "dumb" ] && PS1='$ '

### Source additional functions
if [ -f ${HOME}/.sh_functions ]; then
	. ${HOME}/.sh_functions
fi

### Source host specific definitions ###
if [ -f ${HOME}/.sh_local ]; then
	. ${HOME}/.sh_local
fi
